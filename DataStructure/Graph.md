# 그래프
- 그래프는 연결 되어 있는 객체간의 다양한 관계를 표현할 수 있는 자료 구조
## 1. 인접 행렬을 이용한 표현
1. 무방향 무가중치 그래프
    - 무방향 무가중치 그래프를 인접 행렬로 표기할 경우 간선(i,j)가 그래프에 있다면 행렬 [i][j]와 [j][i]의 값이 1이 되며, 간선가 그래프에 없다면 행렬 [i][j]와 [j][i]의 값이 0이 된다.
2. 무방향 가중치 그래프
    - 무방향 가중치 그래프를 인접 행렬로 표현할 때 간선의 존재를 의미하는 1대신 가중치 값을 인접 행렬에 저장한다.
3. 방향 그래프
    - 방향 그래프를 인접 행렬로 표현할 때 간선 <i, j>가 그래프에 존재하면 행렬 [i][j]의 값이 1이며, 간선 <i, j>가 그래프에 존재하지 않으면 행렬 [i][j]의 값이 0이 된다.

## 그래프의 탐색
### 깊이 우선 탐색
- 깊이 우선 탐색은 시작 정점으로부터 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 될때 다시 가장 가까운 곳으로 연결하여 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법이다.
<img src="https://images.velog.io/images/ekzm8523/post/16c1f488-fbdc-49d9-a9fc-db5b878f5fea/_2020-12-05_18.48.11.png">

깊이 우선 탐색은 그래프의 모든 간선을 조사하므로 정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐ㅅ개하는 시간은 그래프가 인접 리스트로 표현 되어 있다면 O(n+e)이고, 인접 행렬로 표현되어 있다면 O(n^2)로써 인접 리스트의 사용이 인접 행렬의 사용보다 시간적으로 유리하다.
- 코드
    ~~~C
    int n;
    int map[30][30];
    int visit[30];
    void DFS(int v){
        int i;

        visit[v] = 1;
        for(int i = 1; i <= n; i++){
            if(map[v][i] == 1 && !visit[i]){
                printf("%d에서 %d로 이동\n",v ,i);
                DFS(i);
            }
        }
    }

    int main(){
        int start;
        int v1, v2;
        printf(" 정점의 총 개수와 시작 정점을 입력하세요:");
        scanf("%d %d", &n, &start);

        while(1){
            printf("연결할 두 정점을 입력하세요.(에: 3 4)");
            scanf("%d %d", &v1, &v2);
            if(v1 == -1 && v2 == -1){
                break;
            }
            map[v1][v2] = map[v2][v1] = 1;
        }
        DFS(start);

        return 0;
    }
    ~~~
### 너비 우선 탐색 
- 너비 우선 탐색은 시작 정점으로부터 가까운 정점을 모두 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 탐색 방법
<img src="https://velog.velcdn.com/images%2Fekzm8523%2Fpost%2F2da5d64c-e37b-4e38-8641-f105ac6aea7d%2F_2020-12-05_19.10.31.png">

너비 우선 탐색은 그래프가 인접 리스트로 표현되어 있다면 전체 수행 시간이 O(n+e)이며, 인접 행렬로 표현되어 있는 경우는 O(n^2)이다 따라서 너비 우선 탐색도 깊이 우선 탐색과 같이 인접 리스트를 사용하는 것이 이접 행렬을 사용하는 것보다 효율 적이다.

- 코드
    ~~~C
    int n;
    int rear, front;
    int map[30][30];
    int queue[30];
    int visit[30];

    void BFS(int v){
        int i;
        visit[v] = 1;
        printf("%d에서 시작\n", v);
        queue[rear++] = v;
        while(front < rear){
            v = queue[front++];
            for(i = 1; i <= n; i++){
                if(map[v][i] == 1 && !visit[i]){
                    visit[i];
                    printf("%d에서 %d로 이동\n", v, i);
                    queue[rear++] = i;
                }
            }
        }
    }

    int main(){
        int start;
        int v1, v2;

        printf("정점의 총 개수와 시작 정점을 입력하세요:");
        scanf("%d %d", &n, &start);

        while(1){
             printf("연결할 두 정점을 입력하세요:");
            scanf("%d %d", &v1, &v2);
            if(v1 == -1 && v2 == -1){
                break;
            }
            map[v1][v2] = map[2][1] = 1;
        }
        BFS(start);

        return 0;
    }
    ~~~

## 최소 비용 신장 트리
- 어떠한 무방향 가중치 그래프에서 모든 정점들을 연결할 때 최소의 비용으로 연결하는 방법  
- 간선의 가중치 합이 최소여야 함  
- 사이클이 포함되어서는 안 됨

### 최소 비용 신장 트리를 구하는 방법
1. 크루스칼 알고리즘 : 간선 선택 기반의 알고리즘
    - while(N -1 개의 간선을 가질 때 까지 반복){  
        1. 그래프의 간선들 중 **가장 가중치가 낮은 간선**을 선택한다.
        2. 만약 가중치가 낮은 간선을 선택했을 때 싸이클이 형성된다면 그 간선을 제외한다.
        3. 해당 간선을 최소 비용 신장 트리의 집합에 추가한다.   
    
    }

    <img src="https://velog.velcdn.com/images%2Ffldfls%2Fpost%2Fbfc8ca76-a339-45c2-b1cd-17be367b9f8c%2Fimage.png">
2. 프림 알고리즘 : *'시작 정점'*을 결정함
    - while(N - 1개의 간선을 가질 때까지 반복){
        1. 최소 비용 신장트리의 집합과 **'인접한 정점'**과의 간선 중 가중치가 가장 낮은 간선을 선택한다.
        2. 만약 가중치가 낮은 간선을 선택했을 때 싸이클이 형성된다면 그 간선을 제외한다.
        3. 해당 간선을 최소 비용 신장 트리의 집합에 추가한다.  
        
        }

    <img src="https://velog.velcdn.com/images%2Ffldfls%2Fpost%2F4b407297-f4c6-4487-a62b-4d5f52fa64f3%2Fimage.png">